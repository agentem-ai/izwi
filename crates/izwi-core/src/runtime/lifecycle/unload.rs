use crate::catalog::ModelFamily;
use crate::error::Result;
use crate::model::ModelVariant;
use crate::runtime::service::RuntimeService;

impl RuntimeService {
    /// Unload a model from memory.
    pub async fn unload_model(&self, variant: ModelVariant) -> Result<()> {
        match variant.family() {
            ModelFamily::Qwen3Asr | ModelFamily::ParakeetAsr | ModelFamily::Qwen3ForcedAligner => {
                self.model_registry.unload_asr(variant).await;
            }
            ModelFamily::SortformerDiarization => {
                self.model_registry.unload_diarization(variant).await;
            }
            ModelFamily::Qwen3Chat | ModelFamily::Gemma3Chat => {
                self.model_registry.unload_chat(variant).await;
            }
            ModelFamily::Lfm2Audio => {
                self.model_registry.unload_lfm2(variant).await;
                self.clear_active_tts_variant().await;
            }
            ModelFamily::Voxtral => {
                self.model_registry.unload_voxtral(variant).await;
            }
            ModelFamily::Qwen3Tts => {
                let mut model_guard = self.tts_model.write().await;
                *model_guard = None;
                drop(model_guard);
                self.clear_active_tts_variant().await;
            }
            ModelFamily::Tokenizer => {
                let mut tokenizer_guard = self.tokenizer.write().await;
                *tokenizer_guard = None;
            }
        }

        self.model_manager.unload_model(variant).await
    }
}
