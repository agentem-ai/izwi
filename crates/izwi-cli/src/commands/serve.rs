use crate::error::{CliError, Result};
use crate::style::Theme;
use crate::ServeMode;
use console::style;
use std::path::PathBuf;
use std::process::{Child, Command, Stdio};
use std::time::{Duration, Instant};

pub struct ServeArgs {
    pub mode: ServeMode,
    pub host: String,
    pub port: u16,
    pub models_dir: Option<PathBuf>,
    pub max_batch_size: usize,
    pub metal: bool,
    pub threads: Option<usize>,
    pub max_concurrent: usize,
    pub timeout: u64,
    pub log_level: String,
    pub dev: bool,
    pub cors: bool,
    pub no_ui: bool,
}

pub async fn execute(args: ServeArgs) -> Result<()> {
    let theme = Theme::default();

    theme.print_banner();

    let platform = detect_platform();
    println!("   Platform: {}", style(&platform).cyan());

    println!("\n{}", style("Configuration:").bold().underlined());
    println!(
        "  Mode:           {}",
        style(serve_mode_label(&args.mode)).cyan()
    );
    println!("  Host:           {}:{}", args.host, args.port);
    if let Some(ref dir) = args.models_dir {
        println!("  Models dir:     {}", dir.display());
    }
    println!("  Max batch:      {}", args.max_batch_size);
    println!("  Max concurrent: {}", args.max_concurrent);
    println!("  Timeout:        {}s", args.timeout);
    println!(
        "  Metal GPU:      {}",
        if args.metal || cfg!(target_os = "macos") {
            "enabled"
        } else {
            "disabled"
        }
    );
    println!("  Log level:      {}", args.log_level);

    set_server_env(&args);

    println!("\n{}", style("Starting server...").bold());
    let mut server_child = spawn_server(&args)?;

    let connect_host = server_connect_host(&args.host);
    let api_endpoint = format!("http://{}:{}/v1", connect_host, args.port);
    let web_ui = format!("http://{}:{}", connect_host, args.port);

    match &args.mode {
        ServeMode::Server => {
            println!("\n{}", style("Server is running!").green().bold());
            println!("  API endpoint: {}", style(&api_endpoint).cyan());
            if !args.no_ui {
                println!("  Web UI:       {}", style(&web_ui).cyan());
            }
            println!("\nPress Ctrl+C to stop the server.\n");

            let status = server_child
                .wait()
                .map_err(|e| CliError::Other(format!("Server error: {}", e)))?;

            if !status.success() {
                return Err(CliError::Other(format!(
                    "Server exited with code: {:?}",
                    status.code()
                )));
            }
        }
        ServeMode::Desktop => {
            if let Err(err) = wait_for_server_ready(&api_endpoint, Duration::from_secs(30)).await {
                let _ = shutdown_child(&mut server_child, "server");
                return Err(err);
            }

            println!("\n{}", style("Server is running!").green().bold());
            println!("  API endpoint: {}", style(&api_endpoint).cyan());
            println!("  Desktop URL:  {}", style(&web_ui).cyan());
            println!("  Launching desktop app...");

            let mut desktop_child = spawn_desktop(&args, &web_ui)?;
            println!("\n{}", style("Desktop app is running.").green().bold());
            println!("Close the desktop window or press Ctrl+C to stop.\n");

            supervise_desktop_mode(&mut server_child, &mut desktop_child).await?;
        }
        ServeMode::Web => {
            if let Err(err) = wait_for_server_ready(&api_endpoint, Duration::from_secs(30)).await {
                let _ = shutdown_child(&mut server_child, "server");
                return Err(err);
            }

            println!("\n{}", style("Server is running!").green().bold());
            println!("  API endpoint: {}", style(&api_endpoint).cyan());

            if args.no_ui {
                eprintln!(
                    "{}",
                    style("Web mode requested with --no-ui; opening API root instead.").yellow()
                );
            }

            println!("  Web URL:      {}", style(&web_ui).cyan());
            println!("  Launching browser...");

            if let Err(err) = open_in_browser(&web_ui) {
                eprintln!(
                    "{}",
                    style(format!(
                        "Could not launch browser automatically: {}. Open {} manually.",
                        err, web_ui
                    ))
                    .yellow()
                );
            } else {
                println!("{}", style("  Browser opened.").dim());
            }

            println!("\nPress Ctrl+C to stop the server.\n");

            let status = server_child
                .wait()
                .map_err(|e| CliError::Other(format!("Server error: {}", e)))?;

            if !status.success() {
                return Err(CliError::Other(format!(
                    "Server exited with code: {:?}",
                    status.code()
                )));
            }
        }
    }

    Ok(())
}

fn serve_mode_label(mode: &ServeMode) -> &'static str {
    match mode {
        ServeMode::Server => "server",
        ServeMode::Desktop => "desktop",
        ServeMode::Web => "web",
    }
}

fn set_server_env(args: &ServeArgs) {
    std::env::set_var("RUST_LOG", &args.log_level);
    std::env::set_var("IZWI_HOST", &args.host);
    std::env::set_var("IZWI_PORT", args.port.to_string());
    std::env::set_var("IZWI_MAX_BATCH_SIZE", args.max_batch_size.to_string());
    std::env::set_var("IZWI_MAX_CONCURRENT", args.max_concurrent.to_string());
    std::env::set_var("IZWI_TIMEOUT", args.timeout.to_string());
    std::env::set_var("IZWI_SERVE_MODE", serve_mode_label(&args.mode));

    if args.metal || cfg!(target_os = "macos") {
        std::env::set_var("IZWI_USE_METAL", "1");
    }

    if let Some(threads) = args.threads {
        std::env::set_var("IZWI_NUM_THREADS", threads.to_string());
    }

    if let Some(ref dir) = args.models_dir {
        std::env::set_var("IZWI_MODELS_DIR", dir.to_string_lossy().to_string());
    }

    if args.cors {
        std::env::set_var("IZWI_CORS", "1");
    }
}

fn spawn_server(args: &ServeArgs) -> Result<Child> {
    let server_binary = if args.dev {
        "cargo".to_string()
    } else {
        let binary_name = platform_binary_name("izwi-server");
        let binary_path = std::env::current_exe()
            .ok()
            .and_then(|p| p.parent().map(|p| p.to_path_buf()))
            .map(|p| p.join(&binary_name))
            .or_else(|| {
                std::env::current_dir()
                    .ok()
                    .map(|p| p.join("target/release").join(&binary_name))
            })
            .unwrap_or_else(|| PathBuf::from(&binary_name));

        if binary_path.exists() {
            binary_path.to_string_lossy().to_string()
        } else {
            println!("  {}", style("Using development mode (cargo run)").yellow());
            "cargo".to_string()
        }
    };

    let mut cmd = if server_binary == "cargo" {
        let mut c = Command::new("cargo");
        c.arg("run").arg("--bin").arg("izwi-server");
        if !args.dev {
            c.arg("--release");
        }
        c
    } else {
        Command::new(server_binary)
    };

    cmd.env("RUST_LOG", &args.log_level);
    cmd.stdout(Stdio::inherit());
    cmd.stderr(Stdio::inherit());

    cmd.spawn()
        .map_err(|e| CliError::Other(format!("Failed to start server: {}", e)))
}

fn spawn_desktop(args: &ServeArgs, server_url: &str) -> Result<Child> {
    #[cfg(target_os = "macos")]
    if !args.dev {
        if let Some(app_bundle) = resolve_macos_desktop_bundle() {
            println!(
                "  {}",
                style(format!("Using app bundle {}", app_bundle.display())).dim()
            );
            let mut cmd = Command::new("open");
            cmd.arg("-W")
                .arg("-n")
                .arg(&app_bundle)
                .arg("--args")
                .arg("--server-url")
                .arg(server_url)
                .arg("--window-title")
                .arg("Izwi");

            cmd.stdout(Stdio::inherit());
            cmd.stderr(Stdio::inherit());

            return cmd
                .spawn()
                .map_err(|e| CliError::Other(format!("Failed to start desktop app: {}", e)));
        }
    }

    let desktop_binary = if args.dev {
        "cargo".to_string()
    } else {
        let binary_name = platform_binary_name("izwi-desktop");
        let binary_path = std::env::current_exe()
            .ok()
            .and_then(|p| p.parent().map(|p| p.to_path_buf()))
            .map(|p| p.join(&binary_name))
            .or_else(|| {
                std::env::current_dir()
                    .ok()
                    .map(|p| p.join("target/release").join(&binary_name))
            })
            .unwrap_or_else(|| PathBuf::from(&binary_name));

        if binary_path.exists() {
            binary_path.to_string_lossy().to_string()
        } else {
            println!(
                "  {}",
                style("Desktop binary not found, using cargo run fallback").yellow()
            );
            "cargo".to_string()
        }
    };

    let mut cmd = if desktop_binary == "cargo" {
        let mut c = Command::new("cargo");
        c.arg("run").arg("--bin").arg("izwi-desktop");
        if !args.dev {
            c.arg("--release");
        }
        c.arg("--")
            .arg("--server-url")
            .arg(server_url)
            .arg("--window-title")
            .arg("Izwi");
        c
    } else {
        let mut c = Command::new(desktop_binary);
        c.arg("--server-url")
            .arg(server_url)
            .arg("--window-title")
            .arg("Izwi");
        c
    };

    cmd.stdout(Stdio::inherit());
    cmd.stderr(Stdio::inherit());

    cmd.spawn()
        .map_err(|e| CliError::Other(format!("Failed to start desktop app: {}", e)))
}

#[cfg(target_os = "macos")]
fn resolve_macos_desktop_bundle() -> Option<PathBuf> {
    if let Some(path) = std::env::var_os("IZWI_DESKTOP_APP") {
        let candidate = PathBuf::from(path);
        if candidate.exists() {
            return Some(candidate);
        }
    }

    if let Ok(exe) = std::env::current_exe() {
        if let Some(bundle) = find_macos_bundle_ancestor(&exe) {
            return Some(bundle);
        }

        if let Some(parent) = exe.parent() {
            let sibling_bundle = parent.join("Izwi.app");
            if sibling_bundle.exists() {
                return Some(sibling_bundle);
            }
        }
    }

    if let Ok(cwd) = std::env::current_dir() {
        let local_bundle = cwd
            .join("target")
            .join("release")
            .join("bundle")
            .join("macos")
            .join("Izwi.app");
        if local_bundle.exists() {
            return Some(local_bundle);
        }
    }

    let applications_bundle = PathBuf::from("/Applications/Izwi.app");
    if applications_bundle.exists() {
        Some(applications_bundle)
    } else {
        None
    }
}

#[cfg(target_os = "macos")]
fn find_macos_bundle_ancestor(path: &std::path::Path) -> Option<PathBuf> {
    path.ancestors()
        .find(|ancestor| ancestor.extension().and_then(|ext| ext.to_str()) == Some("app"))
        .map(|ancestor| ancestor.to_path_buf())
}

fn open_in_browser(url: &str) -> Result<()> {
    #[cfg(target_os = "macos")]
    let mut cmd = {
        let mut c = Command::new("open");
        c.arg(url);
        c
    };

    #[cfg(target_os = "windows")]
    let mut cmd = {
        let mut c = Command::new("cmd");
        c.args(["/C", "start", "", url]);
        c
    };

    #[cfg(all(unix, not(target_os = "macos")))]
    let mut cmd = {
        let mut c = Command::new("xdg-open");
        c.arg(url);
        c
    };

    cmd.stdout(Stdio::null());
    cmd.stderr(Stdio::null());
    cmd.spawn()
        .map_err(|e| CliError::Other(format!("Failed to launch browser: {}", e)))?;
    Ok(())
}

async fn wait_for_server_ready(api_endpoint: &str, timeout: Duration) -> Result<()> {
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(2))
        .build()?;

    let health_url = format!("{}/health", api_endpoint);
    let deadline = Instant::now() + timeout;

    loop {
        if let Ok(resp) = client.get(&health_url).send().await {
            if resp.status().is_success() {
                return Ok(());
            }
        }

        if Instant::now() >= deadline {
            return Err(CliError::Other(format!(
                "Server did not become ready within {}s ({})",
                timeout.as_secs(),
                health_url
            )));
        }

        tokio::time::sleep(Duration::from_millis(250)).await;
    }
}

async fn supervise_desktop_mode(server: &mut Child, desktop: &mut Child) -> Result<()> {
    loop {
        if let Some(status) = server.try_wait()? {
            let _ = shutdown_child(desktop, "desktop app");
            return Err(CliError::Other(format!(
                "Server exited while desktop app was running (code: {:?})",
                status.code()
            )));
        }

        if let Some(status) = desktop.try_wait()? {
            if !status.success() {
                eprintln!(
                    "{}",
                    style(format!(
                        "Desktop app exited with code {:?}; shutting down server.",
                        status.code()
                    ))
                    .yellow()
                );
            }
            shutdown_child(server, "server")?;
            return Ok(());
        }

        tokio::time::sleep(Duration::from_millis(250)).await;
    }
}

fn shutdown_child(child: &mut Child, name: &str) -> Result<()> {
    if child.try_wait()?.is_some() {
        return Ok(());
    }

    child
        .kill()
        .map_err(|e| CliError::Other(format!("Failed to stop {}: {}", name, e)))?;

    child
        .wait()
        .map_err(|e| CliError::Other(format!("Failed while waiting for {}: {}", name, e)))?;

    Ok(())
}

fn platform_binary_name(base: &str) -> String {
    if cfg!(windows) {
        format!("{}.exe", base)
    } else {
        base.to_string()
    }
}

fn server_connect_host(host: &str) -> String {
    match host {
        "0.0.0.0" | "::" => "127.0.0.1".to_string(),
        other => other.to_string(),
    }
}

fn detect_platform() -> String {
    let os = std::env::consts::OS;
    let arch = std::env::consts::ARCH;
    let mut features = vec![];

    if cfg!(target_os = "macos") {
        features.push("Metal");
    }

    if std::env::var("CUDA_VISIBLE_DEVICES").is_ok() {
        features.push("CUDA");
    }

    let feature_str = if features.is_empty() {
        String::new()
    } else {
        format!(" [{}]", features.join(", "))
    };

    format!("{}-{}{}", os, arch, feature_str)
}
